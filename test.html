<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>VR Smiley Playground</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <style>
    body {
      margin: 0;
      overflow: hidden;
      background: black;
      font-family: system-ui, sans-serif;
    }

    #ui {
      position: fixed;
      top: 12px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0,0,0,0.6);
      color: white;
      padding: 10px 16px;
      border-radius: 12px;
      z-index: 10;
    }
  </style>
</head>
<body>

<div id="ui">Grab the smileys with your controllers ðŸ™‚</div>

<script type="module">
  import * as THREE from "https://unpkg.com/three@0.160.0/build/three.module.js";
  import { VRButton } from "https://unpkg.com/three@0.160.0/examples/jsm/webxr/VRButton.js";
  import { XRControllerModelFactory } from "https://unpkg.com/three@0.160.0/examples/jsm/webxr/XRControllerModelFactory.js";

  let scene, camera, renderer;
  let controllers = [];
  let grabables = [];
  let tempMatrix = new THREE.Matrix4();
  let raycaster = new THREE.Raycaster();

  init();
  renderer.setAnimationLoop(render);

  function init() {
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x000010);

    camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 100);
    camera.position.set(0, 1.6, 2);

    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.xr.enabled = true;
    document.body.appendChild(renderer.domElement);
    document.body.appendChild(VRButton.createButton(renderer));

    // Lights
    scene.add(new THREE.HemisphereLight(0xffffff, 0x222244, 1));
    const dirLight = new THREE.DirectionalLight(0xffffff, 0.6);
    dirLight.position.set(1, 3, 2);
    scene.add(dirLight);

    // Floating platform
    const platform = new THREE.Mesh(
      new THREE.CylinderGeometry(1.2, 1.2, 0.15, 32),
      new THREE.MeshStandardMaterial({ color: 0x333333 })
    );
    platform.position.y = 1;
    scene.add(platform);

    // Smiley spheres
    const colors = ["#FFD400", "#FF6B6B", "#4DFF88", "#4DA6FF", "#C77DFF"];

    colors.forEach((color, i) => {
      const sphere = createSmileySphere(color);
      sphere.position.set(
        -0.6 + i * 0.3,
        1.25,
        0
      );
      scene.add(sphere);
      grabables.push(sphere);
    });

    // Controllers
    const controllerModelFactory = new XRControllerModelFactory();

    for (let i = 0; i < 2; i++) {
      const controller = renderer.xr.getController(i);
      controller.addEventListener("selectstart", onSelectStart);
      controller.addEventListener("selectend", onSelectEnd);
      scene.add(controller);

      const grip = renderer.xr.getControllerGrip(i);
      grip.add(controllerModelFactory.createControllerModel(grip));
      scene.add(grip);

      controller.userData.grip = grip;
      controllers.push(controller);
    }

    window.addEventListener("resize", onResize);
  }

  function createSmileySphere(color) {
    const canvas = document.createElement("canvas");
    canvas.width = 256;
    canvas.height = 256;
    const ctx = canvas.getContext("2d");

    ctx.fillStyle = color;
    ctx.fillRect(0, 0, 256, 256);

    ctx.fillStyle = "#000";
    ctx.beginPath();
    ctx.arc(80, 90, 18, 0, Math.PI * 2);
    ctx.arc(176, 90, 18, 0, Math.PI * 2);
    ctx.fill();

    ctx.lineWidth = 10;
    ctx.beginPath();
    ctx.arc(128, 130, 70, 0, Math.PI);
    ctx.stroke();

    const texture = new THREE.CanvasTexture(canvas);

    const mesh = new THREE.Mesh(
      new THREE.SphereGeometry(0.12, 32, 32),
      new THREE.MeshStandardMaterial({ map: texture })
    );

    mesh.userData.grabbed = false;
    return mesh;
  }

  function onSelectStart(event) {
    const controller = event.target;
    tempMatrix.identity().extractRotation(controller.matrixWorld);
    raycaster.ray.origin.setFromMatrixPosition(controller.matrixWorld);
    raycaster.ray.direction.set(0, 0, -1).applyMatrix4(tempMatrix);

    const hits = raycaster.intersectObjects(grabables);
    if (hits.length > 0) {
      const obj = hits[0].object;
      controller.attach(obj);
      obj.userData.grabbed = true;
      controller.userData.held = obj;
    }
  }

  function onSelectEnd(event) {
    const controller = event.target;
    const obj = controller.userData.held;
    if (obj) {
      scene.attach(obj);
      obj.userData.grabbed = false;
      controller.userData.held = null;
    }
  }

  function render() {
    grabables.forEach(obj => {
      if (!obj.userData.grabbed) {
        obj.rotation.y += 0.005;
      }
    });

    renderer.render(scene, camera);
  }

  function onResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  }
</script>

</body>
</html>
